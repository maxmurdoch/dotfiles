require "uri"
require "constants/versions"
require "constants/country"
require "restrictions/creditor_restrictor"

class Pay::FlowController < ActionController::Base
  use ActionDispatch::Flash

  protect_from_forgery

  UNSAVED_COMMIT_ACTIONS = %w(change_country change_language).freeze

  before_action :set_variables, only: [:new, :create, :mandate]
  around_action :with_locale, only: [:new, :create, :mandate]
  before_action :check_redirect_flow_completed, only: [:new, :create, :mandate]
  before_action :check_creditor_restrictions, only: [:new, :create]
  before_action :check_and_reset_redirect_flow_expiry, only: [:new, :create, :mandate]

  layout false

  def new
    @customer = Customer.new
    @bank_account = BankAccount.new
  end

  def create
    pending_resource = build_pending_resource

    @customer = pending_resource.pending_customer
    @bank_details_transformer = pending_resource.bank_details_transformer
    @bank_account = pending_resource.pending_customer_bank_account

    if customer_params[:requires_signed_direct_debit_mandate].present?
      flash.now[:error] = @redirect_flow.translate(:requires_signed_mandate_flash)
      return render :new
    end

    return render :new if params[:commit].in?(UNSAVED_COMMIT_ACTIONS)

    if pending_resource.valid_resources?
      pending_resource.save!
      @redirect_flow.reset_integrator_expiry

      redirect_to redirect_uri.to_s
    else
      @bank_details_transformer.attach_errors_to_model(@bank_account)
      flash.now[:error] = @redirect_flow.translate(:errors_flash)
      render :new
    end
  rescue ActiveRecord::RecordInvalid => error
    # We want to hard-raise here so it 500s and goes to Sentry
    raise "Unexpected pay flow validation error: #{error.message}"
  end

  def mandate
    pdf_attrs = params.
      slice(:account_holder_name, :iban, :country_code, :bank_code, :branch_code,
            :account_number, :swedish_identity_number).
      merge(sun: @redirect_flow.sun, scheme: @redirect_flow.scheme).
      symbolize_keys

    pdf = MandatePDF.new(pdf_attrs)

    if pdf.valid?
      send_data pdf.render, type: "application/pdf", disposition: "inline"
    else
      render_explicit_error(code: 400)
    end
  end

  def js
    render file: "/public/js/beta/flow.js.erb", content_type: "application/javascript"
  end

  def bank_name
    country_code = bank_name_params[:country_code]
    branch_code = bank_name_params[:branch_code]

    if branch_code && country_code == Constants::Country::Code::UK
      branch_code = branch_code.gsub(/[-\s]/, '')
      bank_details = BankBranchInformation.from_sort_code(branch_code)
      bank_name = bank_details.try(:fetch, :bank_name, nil)
    else
      bank_details = BankDetailsLookup.new(bank_name_params)
      bank_name = bank_details.bank_name
    end
    render json: Oj.dump(data: { bank_name: bank_name }),
           status: 200
  end

  def flash_key
    (flash.keys.map(&:to_sym) & %i(error success info warning notice alert)).
      first
  end
  helper_method(:flash_key)

  private

  def redirect_uri
    URI(@redirect_flow.success_redirect_url).tap do |uri|
      uri.query = Rack::Utils.parse_nested_query(uri.query).
        merge(redirect_flow_id: @redirect_flow.id).
        to_query
    end
  end

  def set_variables
    customer_params = params.fetch(:customer, {})

    @redirect_flow = RedirectFlowPresenter.new(
      RedirectFlow.find(params[:id]),
      supplied_country_code: supplied_country_code,
      accept_language_header: http_accept_language.header,
      cloudflare_ip_country: request.headers['HTTP_CF_IPCOUNTRY'],
      supplied_locale: customer_params[:language],
      bank_details: customer_params.fetch(:bank_accounts, {}))

    @creditor = RedirectFlowCreditor.new(@redirect_flow.creditor)

    plan = @redirect_flow.authorisation_link.try(:plan)
    if plan.present?
      @subscription = Subscription.build_for_plan(plan: plan)
      @subscription_term = SubscriptionTerm.for(@subscription, @redirect_flow.locale)
      @subscription_amount = ActiveSupport::NumberHelper.number_to_currency(
        @subscription.amount,
        unit: Constants::Currency.unit_for(@subscription.currency),
        locale: @redirect_flow.locale)
    end

    links = @redirect_flow.authorisation_link.try(:paylinks)
    if paylinks.present?
      @paylink = paylinks.first
      @paylink_amount = ActiveSupport::NumberHelper.number_to_currency(
        @paylink.amount,
        unit: Constants::Currency.unit_for(@paylink.currency),
        locale: @redirect_flow.locale
      )
    end
  end

  def with_locale
    I18n.with_locale(@redirect_flow.locale) { yield }
  end

  def check_redirect_flow_completed
    return unless @redirect_flow.pending_resource.present?
    render_explicit_error(message: "The redirect flow has already been completed.",
                          code: 400)
  end

  def check_creditor_restrictions
    return unless creditor_restrictor.account_frozen?
    render_explicit_error(
      message: "This page is currently unavailable. Please try again later",
      code: 400)
  end

  def check_and_reset_redirect_flow_expiry
    if @redirect_flow.expired?
      render_explicit_error(
        message: "Your browser has timed out for security reasons - please start again",
        code: 400)
    else
      @redirect_flow.reset_customer_expiry
    end
  end

  def render_explicit_error(error)
    status = error[:code]
    @error_message = error[:message]
    render file: "public/#{status}", status: status, layout: "error_page"
  end

  # This will re-select the best scheme for the currency (since we now have the customer's
  # bank details we can make a better choice). The only time it will make a difference is
  # upgrading SEPA Core to COR1.
  def build_pending_resource
    pending_resource = @redirect_flow.build_pending_resource(pending_resource_params)
    pending_resource.scheme = MandateSchemeSelector.for(
      @redirect_flow.organisation,
      Constants::Scheme.currency_for(@redirect_flow.scheme),
      pending_resource.bic)
    pending_resource
  end

  def pending_resource_params
    creditor = @redirect_flow.creditor
    organisation = creditor.organisation

    customer_params.
      except(:bank_accounts, :requires_signed_direct_debit_mandate).
      merge(bank_details_params).
      merge(organisation: organisation, creditor: creditor)
  end

  def supplied_country_code
    if action_name == 'mandate'
      params[:country_code] || Ibandit::IBAN.new(params[:iban].to_s).country_code
    else
      params.fetch(:customer, {})[:country_code]
    end
  end

  def bank_details_params
    customer_params.fetch(:bank_accounts, {}).reject { |_key, value| value.blank? }
  end

  def customer_params
    params.
      require(:customer).
      permit(:given_name, :family_name, :company_name, :swedish_identity_number, :email,
             :address_line1, :address_line2, :city, :postal_code, :country_code,
             :requires_signed_direct_debit_mandate, :language,
             bank_accounts: [:account_holder_name, :bank_code, :branch_code,
                             :account_number, :iban])
  end

  def bank_name_params
    params.
      require(:data).
      permit(:country_code, :branch_code, :bank_code, :account_number, :iban)
  end

  def creditor_restrictor
    @creditor_restrictor ||= Restrictions::CreditorRestrictor.new(@redirect_flow.creditor)
  end
end
